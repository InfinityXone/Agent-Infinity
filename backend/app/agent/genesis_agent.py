"""
Genesis Agent Adapter for OpenManusWeb
Connects OpenManusWeb frontend to Genesis backend
"""

import asyncio
import json
import time
import uuid
from typing import Dict, List, Optional, Any
import aiohttp
import websockets
from pathlib import Path

from config.genesis_config import GENESIS_BACKEND_URL, ENDPOINTS, WEBSOCKET_URL, GENESIS_CONFIG


class GenesisAgent:
    """Genesis Agent adapter for OpenManusWeb integration"""
    
    def __init__(self):
        self.backend_url = GENESIS_BACKEND_URL
        self.endpoints = ENDPOINTS
        self.websocket_url = WEBSOCKET_URL
        self.session = None
        self.active_sessions: Dict[str, Dict] = {}
        
    async def __aenter__(self):
        """Async context manager entry"""
        self.session = aiohttp.ClientSession()
        return self
        
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        if self.session:
            await self.session.close()
    
    async def health_check(self) -> Dict[str, Any]:
        """Check Genesis backend health"""
        try:
            async with self.session.get(self.endpoints["health"]) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    return {"status": "unhealthy", "error": f"HTTP {response.status}"}
        except Exception as e:
            return {"status": "unhealthy", "error": str(e)}
    
    async def create_chat_session(self, message: str, user_id: str = None) -> str:
        """Create a new chat session with Genesis backend"""
        try:
            session_data = {
                "message": message,
                "user_id": user_id or str(uuid.uuid4()),
                "timestamp": time.time()
            }
            
            async with self.session.post(
                self.endpoints["chat"], 
                json=session_data,
                headers={"Content-Type": "application/json"}
            ) as response:
                if response.status == 200:
                    result = await response.json()
                    session_id = result.get("session_id")
                    
                    # Store session info
                    self.active_sessions[session_id] = {
                        "id": session_id,
                        "message": message,
                        "status": "processing",
                        "created_at": time.time(),
                        "user_id": user_id
                    }
                    
                    return session_id
                else:
                    raise Exception(f"Failed to create session: HTTP {response.status}")
                    
        except Exception as e:
            raise Exception(f"Error creating chat session: {str(e)}")
    
    async def get_session_status(self, session_id: str) -> Dict[str, Any]:
        """Get the status of a chat session"""
        try:
            async with self.session.get(f"{self.endpoints['chat']}/{session_id}") as response:
                if response.status == 200:
                    return await response.json()
                else:
                    return {"success": False, "error": f"HTTP {response.status}"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def get_thinking_process(self, session_id: str) -> List[Dict[str, Any]]:
        """Get the thinking process for a session"""
        try:
            async with self.session.get(f"{self.endpoints['thinking']}/{session_id}") as response:
                if response.status == 200:
                    result = await response.json()
                    return result.get("thinking_steps", [])
                else:
                    return []
        except Exception as e:
            print(f"Error getting thinking process: {e}")
            return []
    
    async def get_session_files(self, session_id: str) -> List[Dict[str, Any]]:
        """Get files generated by a session"""
        try:
            async with self.session.get(f"{self.backend_url}/job/{session_id}/files") as response:
                if response.status == 200:
                    result = await response.json()
                    return result.get("files", [])
                else:
                    return []
        except Exception as e:
            print(f"Error getting session files: {e}")
            return []
    
    async def get_session_logs(self, session_id: str) -> List[Dict[str, Any]]:
        """Get logs for a session"""
        try:
            async with self.session.get(f"{self.backend_url}/job/{session_id}/logs") as response:
                if response.status == 200:
                    result = await response.json()
                    return result.get("logs", [])
                else:
                    return []
        except Exception as e:
            print(f"Error getting session logs: {e}")
            return []
    
    async def get_workspace_files(self) -> List[Dict[str, Any]]:
        """Get all workspace files"""
        try:
            async with self.session.get(self.endpoints["files"]) as response:
                if response.status == 200:
                    result = await response.json()
                    return result.get("files", [])
                else:
                    return []
        except Exception as e:
            print(f"Error getting workspace files: {e}")
            return []
    
    async def get_file_content(self, file_path: str) -> Optional[str]:
        """Get content of a specific file"""
        try:
            async with self.session.get(f"{self.endpoints['files']}/{file_path}") as response:
                if response.status == 200:
                    result = await response.json()
                    return result.get("content")
                else:
                    return None
        except Exception as e:
            print(f"Error getting file content: {e}")
            return None
    
    async def get_agents(self) -> List[Dict[str, Any]]:
        """Get active Genesis agents"""
        try:
            async with self.session.get(self.endpoints["agents"]) as response:
                if response.status == 200:
                    result = await response.json()
                    return result.get("data", [])
                else:
                    return GENESIS_CONFIG["agents"]  # Fallback to config
        except Exception as e:
            print(f"Error getting agents: {e}")
            return GENESIS_CONFIG["agents"]
    
    async def get_predictions(self) -> List[Dict[str, Any]]:
        """Get financial predictions from Genesis"""
        try:
            async with self.session.get(self.endpoints["predictions"]) as response:
                if response.status == 200:
                    result = await response.json()
                    return result.get("data", [])
                else:
                    return []
        except Exception as e:
            print(f"Error getting predictions: {e}")
            return []
    
    async def start_genesis_system(self) -> Dict[str, Any]:
        """Start the Genesis autonomous system"""
        try:
            async with self.session.post(self.endpoints["genesis_start"]) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    return {"success": False, "error": f"HTTP {response.status}"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    async def get_genesis_status(self) -> Dict[str, Any]:
        """Get Genesis system status"""
        try:
            async with self.session.get(self.endpoints["genesis_status"]) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    return {"success": False, "genesis_active": False}
        except Exception as e:
            return {"success": False, "genesis_active": False}
    
    async def stop_session(self, session_id: str) -> Dict[str, Any]:
        """Stop a chat session"""
        try:
            async with self.session.post(f"{self.endpoints['chat']}/{session_id}/stop") as response:
                if response.status == 200:
                    # Update local session status
                    if session_id in self.active_sessions:
                        self.active_sessions[session_id]["status"] = "stopped"
                    return await response.json()
                else:
                    return {"success": False, "error": f"HTTP {response.status}"}
        except Exception as e:
            return {"success": False, "error": str(e)}
    
    def get_session_info(self, session_id: str) -> Optional[Dict[str, Any]]:
        """Get local session information"""
        return self.active_sessions.get(session_id)
    
    def list_active_sessions(self) -> List[Dict[str, Any]]:
        """List all active sessions"""
        return list(self.active_sessions.values())


class GenesisWebSocketManager:
    """WebSocket manager for real-time Genesis updates"""
    
    def __init__(self):
        self.connections: Dict[str, websockets.WebSocketServerProtocol] = {}
        self.session_rooms: Dict[str, List[str]] = {}
    
    async def connect(self, websocket: websockets.WebSocketServerProtocol, session_id: str):
        """Connect to a session room"""
        connection_id = str(uuid.uuid4())
        self.connections[connection_id] = websocket
        
        if session_id not in self.session_rooms:
            self.session_rooms[session_id] = []
        self.session_rooms[session_id].append(connection_id)
        
        return connection_id
    
    async def disconnect(self, connection_id: str):
        """Disconnect from session"""
        if connection_id in self.connections:
            del self.connections[connection_id]
        
        # Remove from session rooms
        for session_id, connections in self.session_rooms.items():
            if connection_id in connections:
                connections.remove(connection_id)
    
    async def broadcast_to_session(self, session_id: str, message: Dict[str, Any]):
        """Broadcast message to all connections in a session"""
        if session_id in self.session_rooms:
            for connection_id in self.session_rooms[session_id]:
                if connection_id in self.connections:
                    try:
                        await self.connections[connection_id].send(json.dumps(message))
                    except Exception as e:
                        print(f"Error broadcasting to {connection_id}: {e}")


# Global instances
genesis_agent = None
websocket_manager = GenesisWebSocketManager()


async def get_genesis_agent() -> GenesisAgent:
    """Get or create Genesis agent instance"""
    global genesis_agent
    if genesis_agent is None:
        genesis_agent = GenesisAgent()
        await genesis_agent.__aenter__()
    return genesis_agent

